package cl.minsal.semantikos.kernel.daos;

import cl.minsal.semantikos.kernel.util.ConnectionBD;
import cl.minsal.semantikos.model.Description;
import cl.minsal.semantikos.model.DescriptionType;
import cl.minsal.semantikos.model.DescriptionTypeFactory;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.PostConstruct;
import javax.ejb.*;
import java.io.IOException;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static cl.minsal.semantikos.kernel.util.StringUtils.underScoreToCamelCaseJSON;

/**
 * @author Andres Farias.
 */
@Singleton
@Startup
public class DescriptionDAOImpl implements DescriptionDAO {

    /** El logger para esta clase */
    private static final Logger logger = LoggerFactory.getLogger(DescriptionDAOImpl.class);



    @PostConstruct
    private void init() {
        logger.warn("********* EJB inicio");
        System.out.println("****************");
        this.refreshDescriptionTypes();
    }

    @Override
    public List<DescriptionType> getDescriptionTypes() {

        ConnectionBD connect = new ConnectionBD();
        ObjectMapper mapper = new ObjectMapper();
        DescriptionType[] descriptionTypes = new DescriptionType[0];
        String sql = "{call semantikos.get_all_description_types()}";
        try (Connection connection = connect.getConnection();
             CallableStatement call = connection.prepareCall(sql)) {

            call.execute();
            ResultSet rs = call.getResultSet();
            while (rs.next()) {
                String resultJSON = rs.getString(1);
                descriptionTypes = mapper.readValue(underScoreToCamelCaseJSON(resultJSON), DescriptionType[].class);
            }
        } catch (SQLException e) {
            String errorMsg = "Error al recuperar descripciones de la BDD.";
            logger.error(errorMsg, e);
            throw new EJBException(e);
        } catch (IOException e) {
            String errorMsg = "Error al parsear los objetos a JSON.";
            logger.error(errorMsg, e);
            throw new EJBException(e);
        }

        return Arrays.asList(descriptionTypes);
    }

    // TODO: Implementar este método
    @Override
    public List<Description> getDescriptionBy(int id) {
        return null;
    }

    @Override
    public List<Description> getDescriptionsByConceptID(long idConcept) {

        ConnectionBD connect = new ConnectionBD();
        List<Description> descriptions = new ArrayList<>();

        String sql = "{call semantikos.get_descriptions_by_idconcept(?)}";
        try (Connection connection = connect.getConnection();
             CallableStatement call = connection.prepareCall(sql)) {

            call.setLong(1, idConcept);
            call.execute();

            logger.debug("Descripciones recuperadas para concepto con ID=" + idConcept);
            ResultSet rs = call.getResultSet();
            while (rs.next()) {

                long id = rs.getLong("id");
                String descriptionID = rs.getString("description_id");
                long idDescriptionType = rs.getLong("id_description_type");
                String term = rs.getString("term");
                boolean isCaseSensitive = rs.getBoolean("case_sensitive");
                boolean isAutoGenerated = rs.getBoolean("autogenerated");
                boolean isActive = rs.getBoolean("is_active");
                boolean isPublished = rs.getBoolean("is_published");

                DescriptionType descriptionType = DescriptionTypeFactory.getInstance().getDescriptionTypeByID(idDescriptionType);
                Description description = new Description(id, descriptionID, descriptionType, term, isCaseSensitive, isAutoGenerated, isActive, isPublished);
                descriptions.add(description);
            }

        } catch (SQLException e) {
            String errorMsg = "Error al recuperar descripciones de la BDD.";
            logger.error(errorMsg, e);
            throw new EJBException(e);
        }

        return descriptions;
    }

    @Override
    public DescriptionTypeFactory refreshDescriptionTypes() {

        ConnectionBD connect = new ConnectionBD();
        ObjectMapper mapper = new ObjectMapper();

        List<DescriptionType> descriptionTypes = new ArrayList<>();

        /*
         Esta función SQL, al ser invocada, retorna un objeto JSON de este tipo:
        [{"id":1,"name":"FSN","description":"Full Specified Name"},
         {"id":2,"name":"preferido","description":"Descripción Preferida"},
         {"id":3,"name":"sinónimo","description":"Sinónimo"},
         {"id":4,"name":"abreviado","description":"Abreviado"},
         {"id":5,"name":"general","description":"General"},
         {"id":6,"name":"ambiguo","description":"Ambiguo"},
         {"id":7,"name":"mal escrito","description":"Mal Escrito"}]
         */
        String sql = "{call semantikos.get_description_types()}";
        try (Connection connection = connect.getConnection();
             CallableStatement call = connection.prepareCall(sql)) {

            call.execute();
            ResultSet rs = call.getResultSet();

            /* Se recuperan los description types */
            DescriptionTypeDTO[] theDescriptionTypes = new DescriptionTypeDTO[0];
            if (rs.next()) {
                String resultJSON = rs.getString(1);
                theDescriptionTypes = mapper.readValue(underScoreToCamelCaseJSON(resultJSON), DescriptionTypeDTO[].class);
            }

            if (theDescriptionTypes.length > 0) {
                for (DescriptionTypeDTO aDescriptionType : theDescriptionTypes) {
                    DescriptionType descriptionType = aDescriptionType.getDescriptionType();
                    descriptionTypes.add(descriptionType);
                }
            }

            /* Se setea la lista de Tipos de descripción */
            DescriptionTypeFactory.getInstance().setDescriptionTypes(descriptionTypes);
        } catch (SQLException e) {
            String errorMsg = "Error al intentar recuperar Description Types de la BDD.";
            logger.error(errorMsg, e);
            throw new EJBException(errorMsg, e);
        } catch (IOException e) {
            String errorMsg = "Error al intentar parsear Description Types en JSON.";
            logger.error(errorMsg, e);
            throw new EJBException(errorMsg, e);
        }

        return DescriptionTypeFactory.getInstance();
    }

    @Override
    public long createDescription(String descriptionID, long idDescriptionType, String term, boolean caseSensitive, boolean autogeneratedName, boolean active, boolean published, long idStateConcept, long id_user, long idConcept) {

        long id_description;


        ConnectionBD connect = new ConnectionBD();

        String sql = "{call semantikos.create_concept(?,?,?,?,?,?)}";

        try (Connection connection = connect.getConnection();
             CallableStatement call = connection.prepareCall(sql)) {

            call.setString(1, descriptionID);
            call.setLong(2,idDescriptionType);
            call.setString(3,term);
            call.setBoolean(4,caseSensitive);
            call.setBoolean(5,autogeneratedName);
            call.setBoolean(6, active);
            call.setBoolean(7,published);
            call.setLong(8,idStateConcept);
            call.setLong(9,idConcept);

            call.execute();

            ResultSet rs = call.getResultSet();

            if (rs.next()) {
                id_description = rs.getLong(1);
                if(id_description==-1){
                    String errorMsg = "La descripcion no fue creada, descriptionID: " + descriptionID;
                    logger.error(errorMsg);
                    throw new IllegalArgumentException(errorMsg);
                }
            } else {
                String errorMsg = "La descripcion no fue creada, descriptionID: " + descriptionID;
                logger.error(errorMsg);
                throw new IllegalArgumentException(errorMsg);
            }
            rs.close();
        } catch (SQLException e) {
            throw new EJBException(e);
        }


        return id_description;
    }
}

class DescriptionTypeDTO {

    private long id;
    private String name;
    private String description;

    public DescriptionTypeDTO() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public DescriptionType getDescriptionType() {
        return new DescriptionType(this.id, this.name, this.description);
    }

    @Override
    public String toString() {
        return "DescriptionTypeDTO{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", description='" + description + '\'' +
                '}';
    }
}
